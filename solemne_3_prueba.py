# -*- coding: utf-8 -*-
"""Solemne 3 prueba

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oMRbajc3XxYHymb1mq7CetCfpQEmuVDl
"""

# Importar bibliotecas necesarias
import streamlit as st
import pandas as pd
import requests
import matplotlib.pyplot as plt

# Función para obtener datos de la API REST
@st.cache_data
def obtener_datos_api():
    url = "https://restcountries.com/v3.1/all"
    respuesta = requests.get(url)
    if respuesta.status_code == 200:
        datos = respuesta.json()
        return datos
    else:
        st.error("No se pudieron obtener los datos de la API.")
        return None

# Función para procesar datos
def procesar_datos(datos):
    lista_paises = []
    for pais in datos:
        lista_paises.append({
            "Pais": pais.get("name", {}).get("common", "Desconocido"),
            "Continente": pais.get("region", "Desconocido"),
            "Poblacion": pais.get("population", 0),
            "Area": pais.get("area", 0),
            "Fronteras": len(pais.get("borders", [])),
            "Idiomas": len(pais.get("languages", {})),
            "Zonas horarias": len(pais.get("timezones", []))
        })
    return pd.DataFrame(lista_paises)

# Obtener y procesar los datos
datos_api = obtener_datos_api()
df_paises = procesar_datos(datos_api) if datos_api else pd.DataFrame()

# Configurar la estructura de la aplicación
st.title("Solemne 3 = Manipulación y funciones de Streamlit")
st.title("(Datos de Países)")
st.sidebar.title("Navegación")
pagina_seleccionada = st.sidebar.selectbox("Seleccione una página", ["Descripción", "Interacción con Datos", "Visualización Gráfica"])

# Página de Descripción
if pagina_seleccionada == "Descripción":
    st.header("Descripción del Proyecto")
    st.write("Esta aplicación web muestra datos de países obtenidos de una API pública.")
    st.write("Puedes explorar los datos, realizar análisis y visualizar gráficos.")

# Página de Interacción con Datos
elif pagina_seleccionada == "Interacción con Datos":
    st.header("Interacción con los Datos")

    # Mostrar los datos originales
    st.subheader("Datos Originales")
    st.dataframe(df_paises)

    # Selección de columna y cálculos estadísticos
    columna_seleccionada = st.selectbox("Seleccione una columna para análisis estadístico", df_paises.select_dtypes(include=['float64', 'int']).columns)
    if columna_seleccionada:
        media = df_paises[columna_seleccionada].mean()
        mediana = df_paises[columna_seleccionada].median()
        desviacion = df_paises[columna_seleccionada].std()
        st.write(f"**Media de {columna_seleccionada}:** {media}")
        st.write(f"**Mediana de {columna_seleccionada}:** {mediana}")
        st.write(f"**Desviación estándar de {columna_seleccionada}:** {desviacion}")

    # Selección de columna para ordenar
    ordenar_por = st.selectbox("Seleccione una columna para ordenar", df_paises.columns)
    orden_ascendente = st.checkbox("Orden ascendente", value=True)
    df_ordenado = df_paises.sort_values(by=ordenar_por, ascending=orden_ascendente)
    st.subheader("Datos Ordenados")
    st.dataframe(df_ordenado)
    # Botón para descargar los datos ordenados en CSV o Excel

    def convertir_csv(df):
      return df.to_csv(index=False).encode("utf-8")

    csv = convertir_csv(df_ordenado)
    st.download_button("Descargar datos ordenados en CSV", data=csv, file_name="datos_ordenados.csv", mime="text/csv")

    # Filtrar las filas en función de valores en una columna numérica
    columna_filtrar = st.selectbox("Seleccione columna para filtrar", df_paises.select_dtypes(include=['float64', 'int']).columns)
    valor_minimo = st.slider("Valor mínimo para {columna_filtrar}", min_value=int(df_paises[columna_filtrar].min()), max_value=int(df_paises[columna_filtrar].max()))
    df_filtrado = df_paises[df_paises[columna_filtrar] >= valor_minimo]
    st.subheader("Datos Filtrados (Columna: {columna_filtrar} >= {valor_minimo})")
    st.dataframe(df_filtrado)

    # Botón para descargar los datos filtrados en CSV o Excel
    def convertir_csv(df):
        return df.to_csv(index=False).encode("utf-8")

    csv = convertir_csv(df_filtrado)
    st.download_button("Descargar datos filtrados en CSV", data=csv, file_name="datos_filtrados.csv", mime="text/csv")

# Página de Visualización Gráfica
elif pagina_seleccionada == "Visualización Gráfica":
    st.header("Visualización Interactiva")

    # Selección de Tipo de Gráfico
    tipo_grafico = st.selectbox("Seleccione el tipo de gráfico", ["Barra", "Dispersión", "Histograma", "Línea", "Pastel"])

    # Selección de Variables para el Gráfico
    x_var = st.selectbox("Seleccione el eje X", df_paises.select_dtypes(include=['float64', 'int']).columns)
    y_var = st.selectbox("Seleccione el eje Y", df_paises.select_dtypes(include=['float64', 'int']).columns)

    # Controles de Rango Personalizado para los Ejes
    min_x = df_paises[x_var].min()
    max_x = df_paises[x_var].max()
    min_y = df_paises[y_var].min()
    max_y = df_paises[y_var].max()

    x_min = st.slider(f"Limite inferior del eje X", min_value=min_x, max_value=max_x, value=min_x)
    x_max = st.slider(f"Limite superior del eje X", min_value=min_x, max_value=max_x, value=max_x)
    y_min = st.slider(f"Limite inferior del eje Y", min_value=min_y, max_value=max_y, value=min_y)
    y_max = st.slider(f"Limite superior del eje Y", min_value=min_y, max_value=max_y, value=max_y)

    # Filtrar los datos según los rangos seleccionados
    df_filtrado = df_paises[(df_paises[x_var] >= x_min) & (df_paises[x_var] <= x_max) &
                            (df_paises[y_var] >= y_min) & (df_paises[y_var] <= y_max)]

    # Gráfico: Barra, Dispersión, Histograma, Línea, Pastel
    fig, ax = plt.subplots()
    if tipo_grafico == "Barra":
        ax.bar(df_filtrado[x_var], df_filtrado[y_var])
        ax.set_xlabel(x_var)
        ax.set_ylabel(y_var)
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(y_min, y_max)

    elif tipo_grafico == "Dispersión":
        ax.scatter(df_filtrado[x_var], df_filtrado[y_var])
        ax.set_xlabel(x_var)
        ax.set_ylabel(y_var)
        ax.set_xlim(x_min, x_max)
        ax.set_ylim(y_min, y_max)

    elif tipo_grafico == "Histograma":
        ax.hist(df_filtrado[y_var], bins=20)
        ax.set_xlabel(y_var)
        ax.set_ylim(y_min, y_max)


    # Mostrar el gráfico
    st.pyplot(fig)

    # Botón para descargar el gráfico en PNG
    fig.savefig("grafico.png", format="png")
    with open("grafico.png", "rb") as file:
        st.download_button(
            label="Descargar gráfico en PNG",
            data=file,
            file_name="grafico.png",
            mime="image/png"
        )